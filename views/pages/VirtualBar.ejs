<%- include('../partials/header_content') %>
    <html>
    <style>
        body {
            user-select: none;
            background: var(--bg-dark-blue);
            display: grid;
        }

        #virtualbar {
            margin-top: 0.5%;
            max-height: 98%;
            max-width: 98%;
            justify-self: center;
        }
    </style>
    <p id="noPoll">No poll is currently running.</p>
    <canvas id='virtualbar'></canvas>

    </html>
    <script src="/socket.io/socket.io.js"></script>
    <!-- host on server incase of internet outage -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"
        integrity="sha512-ElRFoEQdI5Ht6kZvyzXhYG9NqjtkmlkfYk0wr6wHxU9JEHakS7UJZNeml5ALk+8IKlU6jDgMabC3vkumRokgJA=="
        crossorigin="anonymous" referrerpolicy="no-referrer"></script>

    <script>
        var socket = io()
        var mychart = document.getElementById('virtualbar').getContext("2d")
        var doughnutChart = new Chart(mychart, {
            type: 'doughnut',
            data: {
                labels: [],
                datasets: [{
                    backgroundColor: [],
                    data: []
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: true,
                plugins: {
                    legend: {
                        labels: {
                            font: {
                                size: 15
                            },
                            color: 'black'
                        }

                    }
                }
            }
        })

        let pixRes

        let noPoll = document.getElementById('noPoll')

        // Update the virtual bar
        // Creates new labels and colors, plus imports all new data to the table
        function update(data) {
            if (data.pollStatus) {
                noPoll.style.display = 'none'

                //reset virtual bar
                doughnutChart.data.datasets[0].backgroundColor = []
                doughnutChart.data.datasets[0].data = []

                for (let [username, student] of Object.entries(data.students)) {
                    if (student.break || student.permissions == 0) delete data.students[username]
                }

                let totalStudents = 0
                let totalResponses = 0

                for (const student of Object.keys(data.students)) {
                    if (data.students[student].pollRes) {
                        totalResponses++
                    }
                    totalStudents++
                }

                if (totalStudents == totalResponses) {
                    data.blindPoll = false
                }

                var labelsArray = []
                var pollArray = []

                let studResponses = {}
                // Loops through object to get each label of the possible answers
                // Also, create a new variable for each possible answer
                if (data.blindPoll) {
                    labelsArray.push('Responses')
                    studResponses.responses = 0
                } else {
                    for (const answer of Object.keys(data.posPollResObj)) {
                        labelsArray.push(data.posPollResObj[answer])
                        studResponses[answer] = 0
                    }
                }
                labelsArray.push('No Response')
                studResponses.noResponse = 0

                // Loops through all possible answers and generates a new color variant for each answer
                // All possible answers should have a different color
                if (data.blindPoll) {
                    doughnutChart.data.datasets[0].backgroundColor.push('#FFAA00')
                } else {
                    for (let i = 0; i < Object.keys(data.posPollResObj).length; i++) {
                        let color = ''
                        let CC = '0123456789ABCDEF'
                        let colorI = CC[Math.floor(i / 2)]
                        let colorJ = CC[15 - Math.floor(i / 2)]
                        switch (i % 4) {
                            case 0:
                                color = `#${colorJ}${colorJ}${colorI}${colorI}${colorI}${colorI}`
                                break
                            case 1:
                                color = `#${colorI}${colorI}${colorJ}${colorJ}${colorI}${colorI}`
                                break
                            case 2:
                                color = `#${colorI}${colorI}${colorI}${colorI}${colorJ}${colorJ}`
                                break
                            case 3:
                                color = `#${colorJ}${colorJ}${colorJ}${colorJ}${colorI}${colorI}`
                                break
                        }
                        doughnutChart.data.datasets[0].backgroundColor.push(color)
                    }
                }
                doughnutChart.data.datasets[0].backgroundColor.push('#E1E1E1')
                // Loops through all student answers and adds them to a total tally
                // Student response corresponds with a property name in studResponses
                for (const student of Object.keys(data.students)) {
                    if (data.students[student].pollRes)
                        if (data.blindPoll)
                            studResponses.responses++
                        else studResponses[data.students[student].pollRes]++
                    else studResponses.noResponse++
                }
                //
                for (const responses of Object.keys(studResponses)) {
                    pollArray.push(studResponses[responses])
                }

                doughnutChart.data.labels = labelsArray
                doughnutChart.data.datasets[0].data = pollArray
                doughnutChart.update()
            } else {
                noPoll.style.display = ''
            }
        }

        // Calls for data
        socket.emit('vbData')
        socket.on('vbUpdate', function () {
            socket.emit('vbData')
        })
        // Gets data from server and send it the function
        socket.on('vbData', function (data) {
            data = JSON.parse(data)
            update(data)
        })

    </script>

    <%- include('../partials/footer_content') %>